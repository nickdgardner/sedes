#!/usr/bin/env python3

# Usage:
#   tei2html corpus/shield.xml expectancy.hellenic+archaic.csv > shield.html

import collections
import csv
import getopt
import html
import math
import sys
import re
import unicodedata

import lemma as lemma_mod
import sedes as sedes_mod
import tei

# Colors for low-to-high color scale.
COLOR_LOW  = (0x00, 0x00, 0x00)
COLOR_HIGH = (0xe6, 0xe6, 0xe6)

# Colors for diverging color scale. The extremes are chosen to be different
# colors of equal lightness, with a lighter gray in the middle.
# Used this tool: https://css.land/lch/.
COLOR_DIVERGING_LOW  = (0xb4, 0x5d, 0x48) # lch(50% 45  40)
COLOR_DIVERGING_MID  = (0xf1, 0xf1, 0xf1) # lch(95%  0   0)
COLOR_DIVERGING_HIGH = (0x20, 0x7d, 0xc2) # lch(50% 45 260)

# Increase this to increase the steepness of the tone mapping operation.
SHADE_MAPPING_ADJUST = 1.5

# Endpoints of the legends that illustrate shade mapping.
SHADE_SCALE_RANGE = (-2.0, 2.0)

def usage(file=sys.stdout):
    print(f"""\
Usage: {sys.argv[0]} [OPTION] WORK.xml STATS.csv > WORK.html

WORK.XML is a TEI XML document containing the text of the work.
STATS.csv is statistics on a corpus of text as produced by
the tei2csv and expectancy programs.

  -s NUM, --shade-mapping-adjust=NUM  change steepness of shade mapping
                                      (default {SHADE_MAPPING_ADJUST:.1f})
  -h, --help  show this help
""", end="", file=file)

ExpectancyEntry = collections.namedtuple("ExpectancyEntry", ("x", "z"))

# Parse a float string, but return None for the strings "" and "NA".
def float_or_none(s):
    if s in ("", "NA"):
        return None
    else:
        return float(s)

def parse_expectancy(f):
    stats = {}
    for row in csv.DictReader(f):
        key = (row["lemma"], row["sedes"])
        if key in stats:
            raise ValueError(f"duplicate lemma/sedes pair {key}")
        stats[key] = ExpectancyEntry(
            x = int(row["x"]),
            z = float_or_none(row["z"]),
        )
    return stats

def esc(v):
    return html.escape(v, True)

def tone_map(z):
    # Logistic function.
    return 1.0 / (1.0 + math.exp(-z * SHADE_MAPPING_ADJUST))

def z_css(z):
    if z is None:
        z = 0.0
    return f"z-{int(100 * tone_map(z))}"

def css_color(sr, sg, sb):
    return f"#{sr:02x}{sg:02x}{sb:02x}"

def srgb_component_to_linear(s):
    # https://en.wikipedia.org/wiki/SRGB#The_reverse_transformation
    u = s / 255.0
    if u <= 0.04045:
        return u / 12.92
    else:
        return math.pow((u + 0.055)/1.055, 12.0/5.0)

def linear_component_to_srgb(u):
    # https://en.wikipedia.org/wiki/SRGB#The_forward_transformation_(CIE_XYZ_to_sRGB)
    if u <= 0.0031308:
        s = 12.92 * u
    else:
        s = 1.055 * math.pow(u, 5.0/12.0) - 0.055
    return int(s * 255 + 0.5)

def srgb_to_linear(sr, sg, sb):
    return tuple(srgb_component_to_linear(c) for c in (sr, sg, sb))

def linear_to_srgb(r, g, b):
    return tuple(linear_component_to_srgb(u) for u in (r, g, b))

def interpolate_srgb(x, s1, s2):
    return linear_to_srgb(*((1.0 - x) * u1 + x * u2 for (u1, u2) in zip(srgb_to_linear(*s1), srgb_to_linear(*s2))))

def diverging_scale(x, low, mid, high):
    if x < 0.5:
        return interpolate_srgb((0.5 - x) / 0.5, mid, low)
    else:
        return interpolate_srgb((x - 0.5) / 0.5, mid, high)

# Normalize Unicode text for output. While we do all internal processing in NFD,
# NFC is better for HTML output.
# https://www.w3.org/TR/charmod-norm/#normalizationChoice: "Content authors
# SHOULD use Unicode Normalization Form C (NFC) wherever possible for content."
def normalize(s):
    return unicodedata.normalize("NFC", s)

def assign_sedes_for_line(line):
    """From a line, return a sequence of (word, sedes, shape) tuples. sedes will
    be non-blank if and only if num_scansions is equal to 1."""
    assignments = sedes_mod.analyze(line.text_without_quotes())
    if len(assignments) == 1:
        return tuple(assignments[0])
    else:
        return tuple((word, None, None) for word in line.words())

def process(f, expectancy):
    doc = tei.TEI(f)

    print("<!DOCTYPE html>")
    print("<html>")
    print("<head>")
    print("<meta charset=utf-8>")
    print(f"<title>{esc(doc.title)}</title>")
    print("<style>")
    print("""\
@font-face {
    font-family: "Cardo";
    font-style: normal;
    font-weight: 400;
    font-display: swap;
    src: local("Cardo Regular"), local("Cardo-Regular"), url(fonts/Cardo-Regular.woff) format("woff2");
    unicode-range: U+0370-03FF, U+1F00-1FFF;
}
@font-face {
    font-family: "Cardo";
    font-style: italic;
    font-weight: 400;
    font-display: swap;
    src: local("Cardo Italic"), local("Cardo-Italic"), url(fonts/Cardo-Italic.woff) format("woff2");
    unicode-range: U+0370-03FF, U+1F00-1FFF;
}
@font-face {
    font-family: "Cardo";
    font-style: normal;
    font-weight: 700;
    font-display: swap;
    src: local("Cardo Bold"), local("Cardo-Bold"), url(fonts/Cardo-Bold.woff) format("woff2");
    unicode-range: U+0370-03FF, U+1F00-1FFF;
}

header {
    background-color: ivory;
    position: fixed;
    display: inline-block;
    top: 1em;
    right: 1em;
    z-index: 1;
}

h1 a, h2 a {
    color: inherit;
    text-decoration: inherit;
}

.error {
    background-color: firebrick;
}
.show-undefined-expectancy .undefined-expectancy {
    background-color: gold;
}

/*
.word, .word::before {
    transition: all 0.3s;
}
*/

.line, .grid-markers {
    font-family: "Cardo";
    font-size: 120%;
    line-height: 140%;
}

.line::before {
    content: attr(data-lineno);
    display: inline-block;
    position: absolute;
    left: -4rem;
    width: 3rem;
    text-align: right;
    color: gray;
    font-size: 80%;
}

.text, .grid-markers {
    margin-left: 4rem;
    position: relative;
}
/* Keep background colors and full saturation when printing. */
.text, #vis-helper {
    color-adjust: exact;
    -webkit-print-color-adjust: exact;
}

.grid-markers {
    color: gray;
    opacity: 0;
    visibility: hidden;
    transition-property: opacity, visibility;
    transition-duration: 0.5s;
    height: 2rem;
}
.grid-markers.visible {
    opacity: 1;
    visibility: visible;
}
.grid {
    position: relative;
}
.grid .line {
    visibility: hidden;
}
.grid .line::before, .grid .line .word {
    visibility: visible;
}
.grid .s1,
.grid .s2,
.grid .s2_5,
.grid .s3,
.grid .s4,
.grid .s4_5,
.grid .s5,
.grid .s6,
.grid .s6_5,
.grid .s7,
.grid .s8,
.grid .s8_5,
.grid .s9,
.grid .s10,
.grid .s10_5,
.grid .s11,
.grid .s12
{
    position: absolute;
}
.grid .s1 { left: 0; }
.grid .s2 { left: 5ex; }
.grid .s2_5 { left: 10ex; }
.grid .s3 { left: 16ex; }
.grid .s4 { left: 21ex; }
.grid .s4_5 { left: 26ex; }
.grid .s5 { left: 31ex; }
.grid .s6 { left: 34ex; }
.grid .s6_5 { left: 40ex; }
.grid .s7 { left: 45ex; }
.grid .s8 { left: 50ex; }
.grid .s8_5 { left: 54ex; }
.grid .s9 { left: 59ex; }
.grid .s10 { left: 64ex; }
.grid .s10_5 { left: 68ex; }
.grid .s11 { left: 74ex; }
.grid .s12 { left: 78ex; }
""")

    print("""\
.shade-bubbles .word,
.shade-bubbles-diverging .word {
    --r: 2.5rem; /* radius of 100% circle */
    position: relative;
}
.shade-bubbles .word::before,
.shade-bubbles-diverging .word::before {
    background-color: magenta; /* highlight any missing background-colors */
}
.shade-bubbles .word::before,
.shade-bubbles-diverging .word::before {
    --s: 1.5rem;
    position: absolute;
    opacity: 0.5;
    border-radius: 50%;
    z-index: -1;
    content: "";
    width: var(--s);
    height: var(--s);
    bottom: calc(var(--s) / -2 + 1ex);
    left: calc(var(--s) / -2 + 0.5rem);
}

.size-bubbles .word {
    --r: 2.5rem; /* radius of 100% circle */
    position: relative;
}
.size-bubbles .word::before {
    background-color: magenta; /* highlight any missing background-colors */
}
.size-bubbles .word::before {
    position: absolute;
    background-color: orange;
    opacity: 0.5;
    border-radius: 50%;
    z-index: -1;
    content: "";
    width: var(--s);
    height: var(--s);
    bottom: calc(var(--s) / -2 + 1ex);
    left: calc(var(--s) / -2 + 0.5rem);
}
""")

    def interval_range(start, stop, num_steps):
        return [start + (stop - start) * (float(i) / num_steps) for i in range(num_steps + 1)]

    print("""\
#shade-scale {{
    display: none;
    background: linear-gradient(to right, {});
    color: gray;
    justify-content: space-between;
}}
#vis-helper.shade-text #shade-scale,
#vis-helper.shade-bubbles #shade-scale {{
    display: flex;
}}
""".format(", ".join(css_color(*(interpolate_srgb(tone_map(z), COLOR_LOW, COLOR_HIGH))) for z in interval_range(*SHADE_SCALE_RANGE, 50))))

    print("""\
#shade-diverging-scale {{
    display: none;
    background: linear-gradient(to right, {});
    color: black;
    justify-content: space-between;
}}
#vis-helper.shade-text-diverging #shade-diverging-scale,
#vis-helper.shade-bubbles-diverging #shade-diverging-scale {{
    display: flex;
}}
""".format(", ".join(css_color(*(diverging_scale(tone_map(z), COLOR_DIVERGING_LOW, COLOR_DIVERGING_MID, COLOR_DIVERGING_HIGH))) for z in interval_range(*SHADE_SCALE_RANGE, 50))))

    for n in range(101):
        r = n / 100.0

        shade_color = interpolate_srgb(r, COLOR_LOW, COLOR_HIGH)
        diverging_color = diverging_scale(r, COLOR_DIVERGING_LOW, COLOR_DIVERGING_MID, COLOR_DIVERGING_HIGH)

        print(f".shade-text .sedes .z-{n} {{ color: {css_color(*shade_color)}; }}")
        print(f".shade-text-diverging .sedes .z-{n} {{ color: {css_color(*diverging_color)}; }}")
        print(f".shade-bubbles .sedes .z-{n}::before {{ background-color: {css_color(*shade_color)}; }}")
        print(f".shade-bubbles-diverging .sedes .z-{n}::before {{ background-color: {css_color(*diverging_color)}; }}")
        area = math.sqrt(1.0 - r)
        print(f".size-bubbles .sedes .z-{n}::before {{ --s: calc(var(--r) * {area:.3f}); }}")

    print("</style>")
    print("</head>")

    print("<body>")

    # Format a floating-point number as appropriate for HTML, with a real minus
    # sign.
    def fmt_float(x):
        return esc(f"{x:+.3g}".replace("-", "−"))
    print("""\
<header>
<form id=controls>
<label><input name=grid type=checkbox> Align to <i>sedes</i> grid</label>
<br>
<select name=style>
<option value=>No highlighting</option>
<option value=shade-text>Shade text</option>
<option value=shade-text-diverging>Shade text, diverging</option>
<option value=shade-bubbles>Shade bubbles</option>
<option value=shade-bubbles-diverging>Shade bubbles, diverging</option>
<option value=size-bubbles>Size bubbles</option>
</select>
<br>
<div id=vis-helper>
<div id=shade-scale>
<span>{min}</span><span>{max}</span>
</div>
<div id=shade-diverging-scale>
<span>{min}</span><span>{max}</span>
</div>
</div>
<label><input name=show-undefined-expectancy type=checkbox> Highlight undefined <var>z</var>-scores</label>
</form>
</header>""".format(min = fmt_float(SHADE_SCALE_RANGE[0]), max = fmt_float(SHADE_SCALE_RANGE[1])))

    print("<article>")
    print(f"<h1>{esc(doc.title)}</h1>")

    # Sum of x per lemma.
    sum_x = {}
    for (lemma, _), expectancy_entry in expectancy.items():
        sum_x.setdefault(lemma, 0)
        sum_x[lemma] += expectancy_entry.x

    book_n = None
    for loc, line in doc.lines():
        if loc.book_n != book_n:
            if book_n is not None:
                print("</div>")
                print("</section>")
            print()
            print(f"<section id=\"book-{esc(loc.book_n)}\">")
            print(f"<h2><a href=\"#book-{esc(loc.book_n)}\">{esc(loc.book_n)}</a></h2>")

            print("""\
<div class="grid-markers grid">
<span class="s1">1</span>
<span class="s2">2</span>
<span class="s2_5">2.5</span>
<span class="s3">3</span>
<span class="s4">4</span>
<span class="s4_5">4.5</span>
<span class="s5">5</span>
<span class="s6">6</span>
<span class="s6_5">6.5</span>
<span class="s7">7</span>
<span class="s8">8</span>
<span class="s8_5">8.5</span>
<span class="s9">9</span>
<span class="s10">10</span>
<span class="s10_5">10.5</span>
<span class="s11">11</span>
<span class="s12">12</span>
</div>""")
            print("<div class=text>")
        book_n = loc.book_n

        # Begin line.
        print("<span id=\"book-{book_n}-line-{line_n}\" class=\"line\" data-lineno=\"{line_n}\">".format(book_n=esc(loc.book_n), line_n=esc(loc.line_n)), end="")

        buffered_nonwords = []
        prev_sedes = None
        word_n = 0
        # We will walk word_entries and line.tokens in parallel, popping an
        # entry from word_entries every time a token has type WORD.
        word_entries = list(assign_sedes_for_line(line))
        for token in line.tokens:
            if token.type != tei.Token.Type.WORD:
                if prev_sedes is None:
                    print(esc(normalize(token.text)), end="")
                else:
                    # These nonwords may or may not belong to the currently open
                    # sedes span--it depends on whether the sedes of the next
                    # word is the same or not.
                    buffered_nonwords.append(token)
                continue

            word_n += 1
            word_attrs = collections.OrderedDict({
                "id": f"book-{loc.book_n}-line-{loc.line_n}-word-{word_n}",
                "class": "word",
            })

            while True:
                try:
                    word, sedes, shape = word_entries.pop(0)
                except IndexError:
                    sedes = None
                    shape = None
                    break
                if word:
                    if word.lower() != token.text.lower():
                        print(f"warning: book {loc.book_n} line {loc.line_n} word {word_n} {token.text!r} does not match scansion word {word!r}", file=sys.stderr)
                    break
                # Ignore empty metrical placeholder words (as found in known.py).

            # Is the sedes for this word the the same as the sedes of the
            # previous word (if any)?
            if sedes is not None and sedes == prev_sedes:
                # Include these nonwords in the currently open sedes span.
                print(esc("".join(token.text for token in buffered_nonwords)), end="")
                buffered_nonwords.clear()
            else:
                if prev_sedes is not None:
                    # Close the currently open sedes span.
                    print("</span>", end="")
                # The nonwords in between belong to neither sedes span.
                print(esc(normalize(re.sub(r"\s+", "\n", "".join(token.text for token in buffered_nonwords)))), end="")
                buffered_nonwords.clear()
                if sedes is not None:
                    # Begin new sedes.
                    print("<span class=\"sedes s{}\">".format(esc(sedes.replace(".", "_"))), end="")
            prev_sedes = sedes

            title_attr = []
            lemma = lemma_mod.lookup(word, word)
            assert lemma, (word, lemma)
            if lemma is not None:
                title_attr.append(f"lemma={normalize(lemma)}")
            if sedes is not None:
                title_attr.append(f"sedes={sedes}")
            expectancy_entry = expectancy.get((lemma, sedes))
            if expectancy_entry is not None:
                word_attrs["data-x"] = str(expectancy_entry.x)
                title_attr.append(f"x={expectancy_entry.x}")
                word_attrs["data-sum-x"] = str(sum_x[lemma])
                title_attr.append(f"Σx={sum_x[lemma]}")
                word_attrs["class"] += " " + esc(z_css(expectancy_entry.z))
                if expectancy_entry.z is not None:
                    z_fmt = f"{expectancy_entry.z:+.8}"
                    word_attrs["data-z"] = z_fmt
                    title_attr.append(f"z={z_fmt.replace('-', '−')}")
                else:
                    word_attrs["class"] += " " + "undefined-expectancy"
            else:
                print(f"warning: no expectancy score for book {loc.book_n} line {loc.line_n} word {word_n}: {word} {lemma!r}/{sedes}", file=sys.stderr)
                word_attrs["class"] += " error"
            if shape is not None:
                title_attr.append(f"shape={shape}")
            if title_attr:
                word_attrs["title"] = " ".join(title_attr)

            # Span for a single word.
            print("<span", end="")
            for attr, value in word_attrs.items():
                print(f" {esc(attr)}=\"{esc(value)}\"", end="")
            print(f">{esc(normalize(token.text))}</span>", end="")

        if word_entries:
            print(f"warning: book {loc.book_n} line {loc.line_n} word {word_n} leftover scansion words {word_entries}", file=sys.stderr)

        if prev_sedes is not None:
            # Close the last remaining open sedes span.
            print("</span>", end="")
        print(esc(normalize("".join(token.text for token in buffered_nonwords))), end="")
        buffered_nonwords.clear()

        # End line.
        print("</span>")
        print("<br>")

    if book_n is not None:
        print("</div>")
        print("</section>")

    print("</article>")
    print("</body>")
    print("""
<script>
const ALL_STYLES = [
    "shade-text",
    "shade-text-diverging",
    "shade-bubbles",
    "shade-bubbles-diverging",
    "size-bubbles",
];
const CONTROLS = document.getElementById("controls");
CONTROLS["grid"].addEventListener("change", event => {
    for (let elem of document.querySelectorAll(".grid-markers")) {
        elem.classList.toggle("visible", event.target.checked);
    }
    for (let elem of document.querySelectorAll(".text")) {
        elem.classList.toggle("grid", event.target.checked);
    }
});
CONTROLS["grid"].dispatchEvent(new Event("change"));
const VIS_HELPER = document.getElementById("vis-helper");
CONTROLS["style"].addEventListener("change", event => {
    for (let elem of document.querySelectorAll(".text")) {
        elem.classList.remove(...ALL_STYLES);
        if (event.target.value)
            elem.classList.add(event.target.value);
    }
    VIS_HELPER.classList.remove(...ALL_STYLES);
    if (event.target.value)
        VIS_HELPER.classList.add(event.target.value);
});
CONTROLS["style"].dispatchEvent(new Event("change"));
CONTROLS["show-undefined-expectancy"].addEventListener("change", event => {
    for (let elem of document.querySelectorAll(".text")) {
        elem.classList.toggle("show-undefined-expectancy", event.target.checked);
    }
});
CONTROLS["show-undefined-expectancy"].dispatchEvent(new Event("change"));
</script>
""")
    print("</html>")

opts, args = getopt.gnu_getopt(sys.argv[1:], "hs:", ["help", "shade-mapping-adjust="])
for o, a in opts:
    if o in ("-h", "--help"):
        usage()
        sys.exit(0)
    elif o in ("-s", "--shade-mapping-adjust"):
        SHADE_MAPPING_ADJUST = float(a)

try:
    tei_filename, expectancy_filename = args
except ValueError:
    print("error: usage error", file=sys.stderr)
    print(file=sys.stderr)
    usage(sys.stderr)
    sys.exit(1)

with open(expectancy_filename) as expectancy_file:
    expectancy = parse_expectancy(expectancy_file)

with open(tei_filename) as tei_file:
    process(tei_file, expectancy)
